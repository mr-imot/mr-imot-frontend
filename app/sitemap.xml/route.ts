import { getBaseUrl } from '@/lib/sitemap-utils'

// Refresh sitemap periodically to pick up new content
export const revalidate = 3600 // 1 hour

type SitemapIndexEntry = {
  url: string
  lastModified?: Date
}

function buildSitemapIndexXml(entries: SitemapIndexEntry[]): string {
  const items = entries
    .map((entry) => {
      const lastMod = entry.lastModified
        ? `<lastmod>${entry.lastModified.toISOString()}</lastmod>`
        : ''
      return `<sitemap><loc>${entry.url}</loc>${lastMod}</sitemap>`
    })
    .join('')

  return [
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">',
    items,
    '</sitemapindex>',
  ].join('')
}

// Get public sitemap URL (via frontend rewrite to backend)
// Sitemaps are served at mrimot.com/sitemaps/... (not api.mrimot.com)
function getPublicSitemapUrl(path: string, baseUrl: string): string {
  // Remove leading slash from path if present
  const cleanPath = path.startsWith('/') ? path.slice(1) : path
  return `${baseUrl}/sitemaps/${cleanPath}`
}

// Helper to get projects count and chunks from backend
async function getProjectsChunkInfo(): Promise<{ total: number; chunks: number }> {
  try {
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'https://api.mrimot.com'
    const baseApiUrl = apiUrl.replace(/\/$/, '')
    const response = await fetch(`${baseApiUrl}/api/v1/sitemaps/projects/count`, {
      next: { revalidate: 3600 }, // Cache for 1 hour
    })
    
    if (!response.ok) {
      console.warn('[sitemap] Failed to fetch projects count from backend')
      return { total: 0, chunks: 0 }
    }
    
    const data = await response.json()
    return {
      total: data.total || 0,
      chunks: data.chunks || 0,
    }
  } catch (error) {
    console.error('[sitemap] Error fetching projects chunk info:', error)
    return { total: 0, chunks: 0 }
  }
}

export async function GET(): Promise<Response> {
  const baseUrl = getBaseUrl()
  const now = new Date()

  try {
    // Get projects chunk info from backend
    const { chunks: numChunks } = await getProjectsChunkInfo()

    const sitemaps: SitemapIndexEntry[] = [
      // Static and news sitemaps (still generated by frontend)
      {
        url: `${baseUrl}/sitemap/static/sitemap.xml`,
        lastModified: now,
      },
      {
        url: `${baseUrl}/sitemap/news/sitemap.xml`,
        lastModified: now,
      },
      // Backend-generated sitemaps (primary source) - served via frontend rewrite
      {
        url: getPublicSitemapUrl('cities.xml', baseUrl),
        lastModified: now,
      },
      {
        url: getPublicSitemapUrl('developers.xml', baseUrl),
        lastModified: now,
      },
    ]

    // Add project chunk sitemaps from backend
    for (let n = 1; n <= numChunks; n++) {
      sitemaps.push({
        url: getPublicSitemapUrl(`projects/${n}.xml`, baseUrl),
        lastModified: now,
      })
    }

    return new Response(buildSitemapIndexXml(sitemaps), {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'public, max-age=3600, s-maxage=3600',
      },
    })
  } catch (error) {
    console.error('[sitemap] Error generating sitemap index:', error)
    // Return minimal index with static sitemaps only (fallback)
    const fallback = buildSitemapIndexXml([
      {
        url: `${baseUrl}/sitemap/static/sitemap.xml`,
        lastModified: now,
      },
      {
        url: `${baseUrl}/sitemap/news/sitemap.xml`,
        lastModified: now,
      },
      // Try to include backend sitemaps even in fallback
      {
        url: getPublicSitemapUrl('cities.xml', baseUrl),
        lastModified: now,
      },
      {
        url: getPublicSitemapUrl('developers.xml', baseUrl),
        lastModified: now,
      },
    ])
    return new Response(fallback, {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'public, max-age=3600, s-maxage=3600',
      },
    })
  }
}
